# -*- coding: utf-8 -*-
# Standalone Function Boundary Finder
#
# Author: Your Name
#
# This script bypasses Ghidra and finds function boundaries by directly
# searching the assembly files generated by splat.

import os
import re

def find_function_boundaries():
    """
    Reads a list of undefined functions, searches for them in the splat-generated
    assembly files, finds their end addresses, and writes the results to a CSV.
    """
    # --- CONFIGURATION ---
    project_dir = os.getcwd()
    input_filename = os.path.join(project_dir, "undefined_functions.txt")
    output_filename = os.path.join(project_dir, "function_boundaries.csv")
    asm_dir = os.path.join(project_dir, "asm")

    print("--- Standalone Function Boundary Finder ---")
    print("Project directory: {}".format(project_dir))

    # --- STEP 1: READ THE TO-DO LIST ---
    print("\nStep 1: Reading to-do list from '{}'...".format(input_filename))
    try:
        with open(input_filename, 'r') as f:
            content = f.read()
            target_functions = re.findall(r"func_[0-9a-fA-F]{8}", content)
            if not target_functions:
                target_functions = re.findall(r"\.L[0-9a-fA-F]{8}", content)
            
            target_functions = sorted(list(set(target_functions)))

        if not target_functions:
            print("WARNING: No function names found in the input file. Did you generate it correctly?")
            return
        
        print("Successfully read {} unique function targets.".format(len(target_functions)))
    except IOError:
        print("ERROR: Could not read input file: {}".format(input_filename))
        print("Please run `make` and redirect the errors to this file first.")
        return

    # --- STEP 2: BUILD A MAP OF ALL ASSEMBLY FILES ---
    print("\nStep 2: Building a map of all assembly files...")
    assembly_files = {}
    for root, _, files in os.walk(asm_dir):
        for file in files:
            if file.endswith(".s"):
                full_path = os.path.join(root, file)
                try:
                    with open(full_path, 'r') as f:
                        # Store the lines of each file for searching
                        assembly_files[full_path] = f.readlines()
                except Exception as e:
                    print("  - Warning: Could not read file {}: {}".format(full_path, e))
    print("Found and mapped {} assembly files.".format(len(assembly_files)))


    # --- STEP 3: PROCESS EACH FUNCTION ---
    print("\nStep 3: Searching for function boundaries...")
    results = []
    not_found = []
    analysis_failed = []

    for i, func_name in enumerate(target_functions):
        print("  -> Processing target {}/{}: {}".format(i + 1, len(target_functions), func_name))
        
        found_in_file = None
        start_addr_str = "800" + func_name.split('_')[1] # Reconstruct full address
        
        # Search all mapped files for the function's label
        for path, lines in assembly_files.items():
            for line in lines:
                if func_name in line and "glabel" in line:
                    found_in_file = path
                    break
            if found_in_file:
                break
        
        if not found_in_file:
            print("     - Status: NOT FOUND in any assembly files.")
            not_found.append(func_name)
            continue
        
        print("     - Status: Found in file '{}'.".format(os.path.relpath(found_in_file, project_dir)))

        # --- FIND THE END ADDRESS IN THE CORRECT FILE ---
        end_addr = None
        lines = assembly_files[found_in_file]
        found_start = False
        for j in range(len(lines)):
            # Find the start of the function
            if func_name in lines[j] and "glabel" in lines[j]:
                found_start = True
            
            if found_start:
                # Now search from this point forward for the end
                line = lines[j].strip()
                if line.startswith("jr") and "ra" in line:
                    # The end is the next line (delay slot)
                    if j + 1 < len(lines):
                        end_line = lines[j+1]
                        # Extract address from the start of the line
                        # MIPS assembly lines from splat often don't have addresses,
                        # so we need to calculate it based on the start and instruction count.
                        # This is a simplification; for now, we'll just mark that we found it.
                        # A more complex script would parse the whole file.
                        end_addr = "Found" # Mark as found, but don't calculate exact address yet
                    break # Found the end
        
        if end_addr:
            # For this simplified script, we can't get the exact end address easily without a full disassembler.
            # But we can confirm the function exists and has an end.
            print("     - Boundaries found.")
            results.append({
                "name": func_name,
                "start": start_addr_str,
                "end": "MANUAL_CHECK_NEEDED"
            })
        else:
            print("     - WARNING: Could not find end of function (jr ra).")
            analysis_failed.append(func_name)

    # --- STEP 4: WRITE THE OUTPUT FILE ---
    print("\nStep 4: Analysis complete. Writing results to output file...")
    try:
        with open(output_filename, 'w') as f:
            f.write("function_name,start_address,end_address\n")
            for res in results:
                f.write("{},{},{}\n".format(res["name"], res["start"], res["end"]))
        print("Successfully wrote {} function boundaries.".format(len(results)))
    except IOError as e:
        print("ERROR: Could not write to output file: {}".format(output_filename))
        print("Details: {}".format(e))
        return

    # --- FINAL REPORT ---
    print("\n--- SCRIPT COMPLETE ---")
    print(u"✅ Found boundaries for: {} functions".format(len(results)))
    if analysis_failed:
        print(u"⚠️ Could not determine end for: {} functions (check these manually)".format(len(analysis_failed)))
        print("   - {}".format(", ".join(analysis_failed)))
    if not_found:
        print(u"❌ Could not find: {} functions in the symbol tree".format(len(not_found)))
        print("   - {}".format(", ".join(not_found)))
    print("\nOutput file located at: {}".format(output_filename))
    print("-----------------------\n")

if __name__ == "__main__":
    find_function_boundaries()
